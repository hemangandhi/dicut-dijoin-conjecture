<!DOCTYPE html>
<html>
    <head>
        <meta content="width=device-width, initial-scale=1.0" name="viewport">
        <meta content="Heman Gandhi" name="author">
        <title>Disjoint Disjoins vs. Minimal Dicuts</title>
        <script type="text/javascript" src="graph-util.js"></script>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css"/>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
	<style>
	  html, body {
	      /*no x-overflow ffs*/
	      width: 99%;
	      height: 100%;
	  }
	  
	  #easel {
	      border: 1px solid black;
	      width: 100%;
	      height: 80%;
	  }

	  .wrapper {
	      border: 1px dotted gray;
	  }

	  #notifications {
	      color: red;
	  }
	</style>
    </head>
    <body>
      <div id="easel"></div>
      <div class="wrapper">
	Notifications:
	<div id="notifications">
	  Please click on the edit button in the black box above to start constructing a graph.
	  Whenever you alter an edge (add, edit, or remove), the sections below and this text will be updated with the relevant data automatically.
	</div>
      </div>
      <div class="wrapper">
	A minimal dicut:
	<div id="dicut"></div>
      </div>
      <div class="wrapper">
	A set of disjoint dijoins:
	<div id="dijoins"></div>
      </div>
      <div class="wrapper">
	More information: This site is created to provide a quick way to check examples on whether they are counter-examples of the
	<a href="http://www.openproblemgarden.org/op/woodalls_conjecture">Woodhall conjecture</a>. The source code is available on
	<a href="https://github.com/hemangandhi/dicut-dijoin-conjecture" alt="Read the README first if you're interested in the code.">GitHub</a>.
	This would've been much more difficult if it wasn't for the brilliance of <a href="https://visjs.org/">vis JS</a>, which powers all of the
	graph interaction and rendering (and the delightful spring-like motion).
	<br/>
	To use this site, you can click the edit button on the top left. There's little incentive to exit out of this editing mode. In this mode you can:
	<ul>
	  <li>Add a node (by clicking on "add node" and then clicking on an empty space in the black box): note that this will not update information about the conjecture.</li>
	  <li>Add an edge (by clicking "add edge" and dragging between nodes): this will update data about the conjecture.</li>
	  <li>Delete a node or edge (by clicking on that node or edge and then clicking the "delete selection" button): this will update data about the conjecture.</li>
	  <li>Move an edge (by clicking on the edge, clicking "edit edge," and then dragging one of the red endpoints): this will update data about the conjecture.</li>
	</ul>
      </div>
    </body>
    <script>
      // Globals
      var easel = document.getElementById('easel');
      var nodes = new vis.DataSet([]);
      var edges = new vis.DataSet([]); 
      var data = {
	  nodes: nodes,
	  edges: edges
      };
      var graph = new Map();
      var tmp_expected_node_id = null;
      var node_id_map = new Map();
      // Needed to map from edge IDs to the actual
      // data for the edge.
      var edge_map = new Map();
      var tmp_expected_edge_info = null;
      // setup for node naming
      nodes.on('add', function(e, props, s) {
	  if (tmp_expected_node_id === null) return;
	  node_id_map.set(props.items[0], tmp_expected_node_id);
	  tmp_expected_node_id = null;
      });
      edges.on('add', function(e, props, s) {
	  if (tmp_expected_edge_info === null) return;
	  edge_map.set(props.items[0], tmp_expected_edge_info);
	  tmp_expected_edge_info = null;
      });
      var addEdgeToGraph = function(edge) {
	  var src = edge.from;
	  var dest = edge.to;
	  if (!graph.has(src)) {
	      graph.set(src, new Set());
	  }
	  graph.get(src).add(dest);
	  tmp_expected_edge_info = edge;
      };
      var removeEdgeByVisId = function(vis_id) {
	  var edge = edge_map.get(vis_id);
	  if (!graph.has(edge.from)) return;
	  var out_edges = graph.get(edge.from);
	  out_edges.delete(edge.to);
	  if (out_edges.size == 0) {
	      graph.delete(edge.from);
	  }
      };

      // Conjecture state.
      var updateConjectureState = function(graph) {
	  var conjecture_info = getGraphConjectureInfo(graph);
	  console.log(conjecture_info);
	  var notifier = document.getElementById('notifications');
	  notifier.innerHTML = "";
	  var dicut_display = document.getElementById('dicut');
	  dicut_display.innerHTML = "";
	  var dijoins_display = document.getElementById('dijoins');
	  dijoins_display.innerHTML = "";
	  var dicut_list = document.createElement('ol');
	  if (conjecture_info.is_error) {
	      notifier.innerText = conjecture_info.error_msg;
	      return;
	  }
	  if (conjecture_info.dicut_edges.length == conjecture_info.disjoint_dijoins.length) {
	      notifier.innerText = "Barring bugs, this does not look like a counter-example. Please verify the examples below.";
	  } else {
	      notifier.innerText = "Barring bugs, this looks like a counter-example. Please verify the examples below.";
	  }
	  for (const [src, dest] of conjecture_info.dicut_edges) {
	      var li = document.createElement('li');
	      li.innerText = "The edge from " + node_id_map.get(src) + " to " + node_id_map.get(dest);
	      dicut_list.appendChild(li);
	  }
	  dicut_display.appendChild(dicut_list);
	  var dijoin_list = document.createElement('ol');
	  for (const dijoin of conjecture_info.disjoint_dijoins) {
	      var li = document.createElement('li');
	      var span = document.createElement('span');
	      span.innerText = "Dijoin that adds edges: ";
	      li.appendChild(span);
	      var per_dijoin = document.createElement('ol');
	      for (const [src, target] of dijoin) {
		  var li2 = document.createElement('li');
		  li2.innerText = "From " + node_id_map.get(target) + " to " + node_id_map.get(src);
		  per_dijoin.appendChild(li2);
	      }
	      li.appendChild(per_dijoin);
	      dijoin_list.appendChild(li);
	  }
	  dijoins_display.appendChild(dijoin_list);
      };

      var node_ctr = 0;
      var options = {
	  manipulation: {
	      enabled: true,
	      addNode: function(node, done) {
		  node.label = '' + node_ctr;
		  node_ctr++;
		  tmp_expected_node_id = node.label;
		  done(node);
	      },
	      addEdge: function(edge, done) {
		  addEdgeToGraph(edge);
		  updateConjectureState(graph);
		  done(edge);
	      },
	      editEdge: function(edge, done) {
		  removeEdgeByVisId(edge.id);
		  addEdgeToGraph(edge);
		  updateConjectureState(graph);
		  done(edge);
	      },
	      deleteEdge: function(edge, done) {
		  removeEdgeByVisId(edge.edges[0]);
		  updateConjectureState(graph);
		  done(edge);
	      },
	      deleteNode: function(selection, done) {
		  for(const node_id of selection.nodes) {
		      node_id_map.delete(node_id);
		  }
		  for(const edge_id of selection.edges) {
		      removeEdgeByVisId(edge_id);
		  }
		  updateConjectureState(graph);
		  done(selection);
	      }
	  },
	  edges: {
	      arrows: 'to'
	  },
      };

      var network = new vis.Network(easel, data, options);
    </script>
</html>
